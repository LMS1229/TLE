# 개요
배열 A={a1,a2,a3,a4,...an}에 대하여 A의 부분합을 구하기 위해선 누적합을 사용한다.
```
* Sum(0)=0;
* Sum(i)=a1+a2+a3+...+ai (1<=i<=n) //a1~ai까지의 합
* PartialSum(start,end)=Sum(end)-Sum(start-1) //1<=start<=end<=n  
```
이 과정은 모든 i(1<=i<=n) 에 대하여 Sum(i) 를 미리 구하는 과정은 O(n)이고  
이를 미리 저장해둔다면 partialSum 함수의 수행시간은 O(1) 이다. 
만약 이때 ai (1<=i<=n)이 바뀐다면 Sum(i)~Sum(n) 의 모든 값을 바꿔야 한다.  
즉, 이 과정은 O(n) 의 시간이 걸린다. 그렇다면 빠르게 갱신할 수 있는 방법은 없을까?
# 세그먼트 트리
이는 세그먼트 트리를 이용하면 해결이 가능하다. 여기선 탑-다운 방식의 세그먼트 트리를 다루겠다.  
세그먼트 트리는 말 그대로 트리의 일종이며 각 노드는 다음과 같은 특징을 가지고 있다.
* 리프 노드: 배열의 원소
* 단말 노드: 왼쪽 자식 노드와 오른쪽 자식 노드의 합
노드의 번호가 x일때 왼쪽 자식 노드는 x\*2,오른쪽 자식노드는 x\*2+1 이다.  
만약 배열의 크기가 7이라면 다음과 같은 형태의 세그먼트 트리가 형성된다.
```
function MakeSegmentTree(begin, last, treeIndex)
  if(begin==last)
      return Segment[treeIndex]=
```
